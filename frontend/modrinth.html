<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Redstone Launcher - Modrinth Browser</title>
<link rel="stylesheet" href="modrinth.css" />
<link rel="stylesheet" href="server.css" />
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>
<div id="toolbar">
  <div class="toolbar-buttons-left">
      <button id="backBtn">⬅</button>
      <button id="forwardBtn">➡</button>
  </div>
<div class="drag-region">Redstone Launcher</div>
<div class="toolbar-buttons">
    <div id="instance-processes"></div>
    <button id="min-btn">—</button>
    <button id="max-btn">◻</button>
    <button id="close-btn">✕</button>
</div>
</div>
<div class="sidebar">
  <ul class="menu top">
    <a href="index.html"><li><i class="material-icons">home</i><span>Home</span></li></a>
    <a href="instances.html"><li><i class="material-icons">play_arrow</i><span>Instances</span></li></a>
    <a href="modrinth.html" class="modrinth"><li><span>Modrinth</span></li></a>
    <a href="server.html"><li><i class="material-icons">storage</i><span>Server Manager</span></li></a>
  </ul>
  <ul class="menu middle" id="instances">
    <li><i class="material-icons">add</i><span>Add an instance</span></li>
  </ul>
  <ul class="menu bottom">
    <li id="update"><i class="material-icons">download</i><span id="updateText">Download the latest update</span></li>
    <li><a href="profile-manager.html"><i class="material-icons">face</i></a><span>Skin, cape changer</span></li>
    <a href="players.html"><li id="players-login"><i class="material-icons">login</i><span>Login</span></li></a>
    <li><a href="settings.html"><i class="material-icons">settings</i></a><span>Settings</span></li>
  </ul>
</div>
<div id="searchPagination">
  <div class="top-row">
    <input type="text" id="searchInput" placeholder="Search projects..." />
    <select id="apiSelector">
      <option value="modrinth">Modrinth</option>
      <option value="curseforge">CurseForge</option>
    </select>
  </div>

  <div class="bottom-row">
    <div id="typeTabs">
      <button class="tab active" data-type="mod">Mod</button>
      <button class="tab" data-type="resourcepack">Resourcepack</button>
      <button class="tab" data-type="datapack">Datapack</button>
      <button class="tab" data-type="shader">Shader</button>
      <button class="tab" data-type="modpack">Modpack</button>
      <button class="tab" data-type="plugin">Plugin</button>
    </div>

    <div id="paginationControls">
      <button id="prevPage">&lt;</button>
      <span id="pageDisplay">1</span>
      <button id="nextPage">&gt;</button>
    </div>
  </div>
</div>

<ul id="modrinthResults"></ul>

<script>
const { ipcRenderer } = require('electron');

let currentPage = 1;
let totalPages = 1;
let currentProjects = [];
const projectsPerPage = 20;

const searchInput = document.getElementById("searchInput");
const prevBtn = document.getElementById("prevPage");
const nextBtn = document.getElementById("nextPage");
const pageDisplay = document.getElementById("pageDisplay");

const resultsList = document.getElementById('modrinthResults');
resultsList.classList.add("mainModView-scrolly");

let profiles = [];
let servers = [];

// Fetch profiles & servers
ipcRenderer.send('get-profiles');
ipcRenderer.on('profiles-list', (e, data) => profiles = data);

async function fetchServers() {
  servers = await ipcRenderer.invoke('list-servers');
}

// Fetch top 20 projects from Modrinth
async function fetchProjects(type, page = 1, search = "") {
  const api = apiSelector.value;
  resultsList.innerHTML = 'Loading...';
  try {
    if (api === "modrinth") {
      const offset = (page - 1) * projectsPerPage;
      let url = `https://api.modrinth.com/v2/search?facets=[["project_type:${type}"]]&limit=${projectsPerPage}&offset=${offset}`;
      if (search) url += `&query=${encodeURIComponent(search)}`;
      const res = await fetch(url);
      const data = await res.json();
      currentProjects = data.hits || [];
      totalPages = Math.ceil((data.total_hits || 0) / projectsPerPage);
      return currentProjects;
    } else {
      const curseforgeTypeMap = {
        mod: 6,           // Minecraft Mods
        resourcepack: 12, // Resource Packs
        shader: 6552,     // Shaders
        modpack: 4471,    // Modpacks
        datapack: 6945,   // Data Packs
        plugin: 5         // Bukkit Plugins
      };

      const classId = curseforgeTypeMap[type] || 6; // Default to mods
      const searchBody = {
        gameId: 432, // 432 = Minecraft
        classId,
        searchFilter: search || "",
        sortField: 2, // Sort by popularity
        pageSize: projectsPerPage,
        index: (page - 1) * projectsPerPage
      };

      const res = await fetch("https://curseforge.tgdoescode.workers.dev/search", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(searchBody)
      });
      const data = await res.json();
      currentProjects = data.data || [];
      totalPages = 1;
      return currentProjects;
    }
  } catch (err) {
    console.error(err);
    resultsList.innerHTML = 'Failed to load projects';
    return [];
  }
}

function formatNumber(num) {
  if (typeof num !== "number" || isNaN(num)) {console.log(num); return "0"};

  if (num >= 1_000_000) return (num / 1_000_000).toFixed(1).replace(/\.0$/, "") + " M";
  if (num >= 1_000) return (num / 1_000).toFixed(1).replace(/\.0$/, "") + " K";
  return num.toString();
}

function openProjectDetails(proj) {
  const api = apiSelector.value;
  if (api === "modrinth") {
    localStorage.setItem("selectedModrinthProject", JSON.stringify(proj));
    localStorage.setItem("selectedProjectType", document.querySelector('#typeTabs .tab.active') ? document.querySelector('#typeTabs .tab.active').dataset.type : 'mod'.toLowerCase());
    window.location.href = "modrinth_project.html";
  } else {
    localStorage.setItem("selectedCurseforgeProject", JSON.stringify(proj));
    localStorage.setItem("selectedProjectType", document.querySelector('#typeTabs .tab.active') ? document.querySelector('#typeTabs .tab.active').dataset.type : 'mod'.toLowerCase());
    window.location.href = "curseforge_project.html";
  }
}


// Render current page projects
function renderProjects(projects) {
  resultsList.innerHTML = '';
  if (!projects.length) {
    resultsList.innerHTML = '<p>No projects found</p>';
    return;
  }

  const api = apiSelector.value;
  projects.forEach(proj => {
    console.log(proj)
    const card = document.createElement("div");
    card.className = "project-card";

    const left = document.createElement("div");
    left.className = "project-left";

    const img = document.createElement("img");
    img.src = proj.icon_url || proj.logo?.url || "";
    left.appendChild(img);

    const info = document.createElement("div");
    info.className = "project-info";
    const title = api === "modrinth" ? proj.title : proj.name;
    const author = api === "modrinth" ? proj.author : proj.authors?.[0]?.name || "Unknown";
    const downloads = api === "modrinth" ? proj.downloads : proj.downloadCount;

    info.innerHTML = `
      <div class="project-title">${title}</div>
      <div class="project-meta">by ${author} • ${formatNumber(downloads)} downloads</div>
    `;
    left.appendChild(info);

    const actions = document.createElement("div");
    actions.className = "project-actions";
    const installBtn = document.createElement("button");
    installBtn.textContent = "Install";
    actions.append(installBtn);

    card.append(left, actions);
    card.onclick = () => openProjectDetails(proj);
    card.style.cursor = "pointer";
    resultsList.appendChild(card);
  });

  updatePaginationDisplay()
}

function updatePaginationDisplay() {
  const pageContainer = document.getElementById("paginationControls");
  pageContainer.innerHTML = "";
  pageContainer.classList.add("pagination-container");

  // --- Prev button ---
  if (currentPage > 1) {
    const prevBtn = document.createElement("button");
    prevBtn.className = "page-btn";
    prevBtn.textContent = "<";
    prevBtn.onclick = async () => {
      currentPage--;
      await loadProjects();
    };
    pageContainer.appendChild(prevBtn);
  }

  // --- Pages list ---
  const span = document.createElement("span");
  span.className = "page-numbers";

  const pagesToShow = [];
  if (currentPage > 1) pagesToShow.push(currentPage - 1);
  pagesToShow.push(currentPage);
  if (currentPage < totalPages) pagesToShow.push(currentPage + 1);

  // Always show first & last if not already included
  if (!pagesToShow.includes(1)) pagesToShow.unshift(1);
  if (!pagesToShow.includes(totalPages)) pagesToShow.push(totalPages);

  span.innerHTML = pagesToShow
    .map(p =>
      p === currentPage
        ? `<span class="page-number current">${p}</span>`
        : `<button class="page-number">${p}</button>`
    )
    .join(" - ");

  pageContainer.appendChild(span);

  // Add click handlers for page buttons
  span.querySelectorAll(".page-number").forEach(btn => {
    if (!btn.classList.contains("current")) {
      btn.onclick = async () => {
        currentPage = parseInt(btn.textContent);
        await loadProjects();
      };
    }
  });

  // --- Next button ---
  if (currentPage < totalPages) {
    const nextBtn = document.createElement("button");
    nextBtn.className = "page-btn";
    nextBtn.textContent = ">";
    nextBtn.onclick = async () => {
      currentPage++;
      await loadProjects();
    };
    pageContainer.appendChild(nextBtn);
  }
}


// Load current page
async function loadProjects() {
  const type = document.querySelector('#typeTabs .tab.active') ? document.querySelector('#typeTabs .tab.active').dataset.type : 'mod';
  const search = searchInput.value.trim();
  const projects = await fetchProjects(type, currentPage, search);
  renderProjects(projects);
}

// Search handler
searchInput.oninput = () => {
  currentPage = 1;
  loadProjects();
};

// Type change & refresh
apiSelector.onchange = () => { currentPage = 1; loadProjects(); };

// Initial load
loadProjects();

// Show install screen with compatible instances/servers
async function openInstallScreen(mod) {
  resultsList.innerHTML = `
    <h3 style="margin-bottom:10px;">Install ${mod.title}</h3>
    <div class="install-scroll-area" id="installArea"></div>
  `;
  const installArea = document.getElementById("installArea");


  const projType = mod.project_type?.toLowerCase();
  const selectedType = document.querySelector('#typeTabs .tab.active') ? document.querySelector('#typeTabs .tab.active').dataset.type : 'mod'.toLowerCase();

  // --- Handle modpacks ---
  if (projType === "modpack") {
    let versions = [];
    try {
      const res = await fetch(`https://api.modrinth.com/v2/project/${mod.project_id}/version`);
      versions = await res.json();
    } catch (err) {
      console.error("Failed to fetch modpack versions:", err);
      installArea.innerHTML += "<p>Failed to fetch modpack versions</p>";
      return;
    }

    if (!Array.isArray(versions) || versions.length === 0) {
      installArea.innerHTML += "<p>No versions found for this modpack</p>";
      return;
    }

    versions.sort((a, b) => new Date(b.date_published) - new Date(a.date_published));

    const list = document.createElement("ul");
    list.className = "uli";

    versions.forEach(v => {
      const li = document.createElement("li");
      li.className = "profile-item";

      const info = document.createElement("div");
      info.className = "profile-info";

      const name = document.createElement("div");
      name.className = "profile-name";
      name.textContent = `${v.name}`;
      info.appendChild(name);

      const details = document.createElement("div");
      details.className = "profile-details";
      details.textContent = `Version: ${v.version_number}`;
      info.appendChild(details);

      li.appendChild(info);

      const installBtn = document.createElement("button");
      installBtn.textContent = "Install";
      installBtn.onclick = async () => {
        const mrpackFile = v.files.find(f => f.url.endsWith(".mrpack"));
        if (!mrpackFile) return alert("No .mrpack file available for this version");

        await ipcRenderer.invoke("install-mrpack-url", mrpackFile.url);
        alert(`Started installation of ${mod.title} (${v.version_number})`);
      };
      li.appendChild(installBtn);

      list.appendChild(li);
    });

    installArea.appendChild(list);
    return;
  }

  // --- Fetch versions ---
  let validVersions = [];
  try {
    const res = await fetch(`https://api.modrinth.com/v2/project/${mod.project_id}/version`);
    const allVersions = await res.json();
    validVersions = Array.isArray(allVersions) ? allVersions : [];
  } catch (err) {
    console.error("Failed to fetch mod versions:", err);
    installArea.innerHTML += "<p>Failed to fetch mod versions</p>";
    return;
  }

  function isCompatible(instanceVersion, loader) {
    return validVersions.some(v => {
      const loaderMap = v.loaders.map(l => (l === "vanilla" ? "vanilla" : l));
      return v.game_versions.includes(instanceVersion) && loaderMap.includes(loader);
    });
  }

  // --- CLIENT INSTANCES ---
  if (
    projType === "shader" ||
    projType === "resourcepack" ||
    (projType === "mod" && selectedType === "mod")
  ) {
    const clientHeader = document.createElement("h4");
    clientHeader.textContent = "Client Instances";
    installArea.appendChild(clientHeader);

    profiles.forEach(p => {
      if (projType === "shader") {
        if (!["fabric", "quilt", "forge", "neoforge"].includes(p.loader)) return;
        if (!validVersions.some(v => v.game_versions.includes(p.version))) return;
      } else if (projType === "mod" && selectedType === "mod") {
        if (!["fabric", "quilt", "forge", "neoforge"].includes(p.loader)) return;
        if (!isCompatible(p.version, p.loader)) return;
      }

      const li = document.createElement("li");
      li.className = "profile-item";

      const img = document.createElement("img");
      img.src = p.icon || "https://tggamesyt.dev/assets/redstone_launcher_defaulticon.png";
      li.appendChild(img);

      const info = document.createElement("div");
      info.className = "profile-info";

      const name = document.createElement("div");
      name.className = "profile-name";
      name.textContent = p.name;
      info.appendChild(name);

      const details = document.createElement("div");
      details.className = "profile-details";
      details.textContent = `v${p.version} • ${p.loader}`;
      info.appendChild(details);

      li.appendChild(info);

      const installBtn = document.createElement("button");
      installBtn.textContent = "Install Here";
      installBtn.onclick = async () => {
        installBtn.textContent = "Installing...";
        installBtn.disabled = true;

        const matchedVersion = validVersions.find(v =>
          v.game_versions.includes(p.version) &&
          v.loaders.includes(p.loader === "vanilla" ? "vanilla" : p.loader)
        );
        if (!matchedVersion) return (installBtn.textContent = "Install failed");

        const fileUrl = matchedVersion.files[0]?.url;
        if (!fileUrl) return (installBtn.textContent = "Install failed");

        await ipcRenderer.invoke("mod-download", {
          server: false,
          id: p.id,
          fileUrl,
          projectType: selectedType
        });

        installBtn.textContent = "Installed";
      };
      li.appendChild(installBtn);

      installArea.appendChild(li);
    });
  }

  // --- SERVER INSTANCES ---
  await fetchServers();
  if (
    projType === "resourcepack" ||
    (projType === "shader" && false) ||
    (projType === "mod" && ["mod", "plugin", "datapack"].includes(selectedType))
  ) {
    const serverHeader = document.createElement("h4");
    serverHeader.textContent = "Servers";
    installArea.appendChild(serverHeader);

    servers.forEach(s => {
      const modded = ["fabric", "quilt", "forge", "neoforge"].includes(s.type);
      const pluginned = ["purpur", "paper"].includes(s.type);

      if (projType === "mod" && selectedType === "mod") {
        if (!modded) return;
      }
      if (projType === "mod" && selectedType === "plugin") {
        if (!mod.categories.includes("paper")) return;
        if (!pluginned) return;
      }
      if (projType === "mod" && selectedType === "datapack") {
        if (!mod.categories.includes("datapack")) return;
      }

      const matchedVersion = validVersions.find(v => v.game_versions.includes(s.version));
      if (!matchedVersion) return;

      const li = document.createElement("li");
      li.className = "profile-item";

      const img = document.createElement("img");
      img.src = s.icon || "https://tggamesyt.dev/assets/redstone_launcher_defaulticon.png";
      li.appendChild(img);

      const info = document.createElement("div");
      info.className = "profile-info";

      const name = document.createElement("div");
      name.className = "profile-name";
      name.textContent = s.name;
      info.appendChild(name);

      const details = document.createElement("div");
      details.className = "profile-details";
      details.textContent = `${s.type} • ${s.version}`;
      info.appendChild(details);

      li.appendChild(info);

      const installBtn = document.createElement("button");
      installBtn.textContent = "Install Here";
      installBtn.onclick = async () => {
        installBtn.textContent = "Installing...";
        installBtn.disabled = true;

        const fileUrl = matchedVersion.files[0]?.url;
        if (!fileUrl) return (installBtn.textContent = "Install failed");

        await ipcRenderer.invoke("mod-download", {
          server: true,
          id: s.name,
          fileUrl,
          projectType: selectedType
        });

        installBtn.textContent = "Installed";
      };
      li.appendChild(installBtn);

      installArea.appendChild(li);
    });
  }
}
// Load top projects
async function loadTopProjects() {
  const type = document.querySelector('#typeTabs .tab.active') ? document.querySelector('#typeTabs .tab.active').dataset.type : 'mod';
  const projects = await fetchProjects(type);
  renderProjects(projects);
}
const typeTabs = document.getElementById("typeTabs");

typeTabs.querySelectorAll(".tab").forEach(tab => {
  tab.addEventListener("click", () => {
    // remove previous active tab
    typeTabs.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
    // activate clicked one
    tab.classList.add("active");

    // optionally reload projects
    currentPage = 1;
    loadProjects();
    loadTopProjects();
  });
});
loadTopProjects();
function updatePresence(details, state = "Idle") {
  ipcRenderer.send('update-discord-presence', { details, state });
}
updatePresence("Browsing on Modrinth")
</script>
<script src="sidebar.js"></script>
</body>
</html>
