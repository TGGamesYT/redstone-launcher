<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Redstone Launcher - Instances</title>
  <link rel="stylesheet" href="server.css">
  <link rel="stylesheet" href="instanceview.css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    .modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}
.modal {
    background: #222;
    padding: 20px;
    border-radius: 8px;
    color: #fff;
}
.modal input {
    width: 100%;
    margin-bottom: 10px;
}
.modal button {
    margin-right: 5px;
}
  </style>
</head>

<body>
<div id="toolbar">
  <div class="toolbar-buttons-left">
      <button id="backBtn">⬅</button>
      <button id="forwardBtn">➡</button>
  </div>
<div class="drag-region">Redstone Launcher</div>
<div class="toolbar-buttons">
    <div id="instance-processes"></div>   
    <button id="min-btn">—</button>
    <button id="max-btn">◻</button>
    <button id="close-btn">✕</button>
</div>
</div>
<div class="sidebar">
  <ul class="menu top">
    <a href="index.html"><li><i class="material-icons">home</i><span>Home</span></li></a>
    <a href="instances.html"><li><i class="material-icons">play_arrow</i><span>Instances</span></li></a>
    <a href="modrinth.html" class="modrinth"><li><span>Modrinth</span></li></a>
    <a href="server.html"><li><i class="material-icons">storage</i><span>Server Manager</span></li></a>
  </ul>
  <ul class="menu middle" id="instances">
    <li><i class="material-icons">add</i><span>Add an instance</span></li>
  </ul>
  <ul class="menu bottom">
    <li id="update"><i class="material-icons">download</i><span id="updateText">Download the latest update</span></li>
    <li><a href="profile-manager.html"><i class="material-icons">face</i></a><span>Skin, cape changer</span></li>
    <a href="players.html"><li id="players-login"><i class="material-icons">login</i><span>Login</span></li></a>
    <li><a href="settings.html"><i class="material-icons">settings</i></a><span>Settings</span></li>
  </ul>
</div>
<br>
  <div id="search-sort">
    <div style="margin-bottom: 10px;">
      <input id="searchInput" type="text" placeholder="Search instances..." style="padding:5px; width:200px;" />

      <select id="filterLoader">
        <option value="">All Loaders</option>
        <option value="vanilla">Vanilla</option>
        <option value="fabric">Fabric</option>
        <option value="quilt">Quilt</option>
        <option value="forge">Forge</option>
        <option value="neoforge">NeoForge</option>
      </select>

      <input id="filterVersion" type="text" placeholder="Filter by version..." style="padding:5px; width:120px;" />
    </div>
    <div style="margin-bottom: 10px;">
      <label for="sortSelect">Sort by: </label>
      <select id="sortSelect">
        <option value="custom">Custom</option>
        <option value="name-asc">By Name (ascending)</option>
        <option value="name-desc">By Name (descending)</option>
        <option value="created-asc">By Creation Date (ascending)</option>
        <option value="created-desc">By Creation Date (descending)</option>
        <option value="lastused-asc">By Last Used (ascending)</option>
        <option value="lastused-desc">By Last Used (descending)</option>
        <option value="loader-asc">By Mod Loader (ascending)</option>
        <option value="loader-desc">By Mod Loader (descending)</option>
        <option value="version-asc">By Game Version (ascending)</option>
        <option value="version-desc">By Game Version (descending)</option>
      </select>
      <button id="editOrderBtn" style="display:none;">Edit Order</button>
    </div>
  </div>
  <ul id="profiles-list" style="max-height: calc(100vh - ( 38px + 112px )); overflow-y: auto; overflow-x: hidden;"></ul>
  <!-- Add Instance Modal -->
  <div id="addInstanceModal"
    style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); justify-content:center; align-items:center;">
    <div style="background:var(--third-color); padding:20px; border-radius:8px; width:300px;">
      <h3>Create Instance</h3>
      <label>Name: <input id="instanceName" placeholder="Never gonna.." /></label>
      <br>
      <label>Version: <select id="instanceVersion"></select><input type="checkbox" id="showAllVersions" style="transform: scale(1.5); transform-origin: center;" /></label>
      <br>
      <label>Modloader:
        <select id="instanceLoader">
          <option value="vanilla">Vanilla</option>
          <option value="fabric">Fabric</option>
          <option value="quilt">Quilt</option>
          <option value="forge">Forge</option>
          <option value="neoforge">NeoForge</option>
        </select>
      </label>
      <br>
      <label>Icon: <input type="file" id="instanceIcon" accept="image/*" /></label>
      <br>
      <button onclick="document.getElementById('importModal').style.display='flex'">Import</button>
      <div style="margin-top:10px;">
        <button id="modalCreateBtn">Create</button>
        <button id="modalCancelBtn">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Import Modal -->
  <div id="importModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; 
  background:rgba(0,0,0,0.5); justify-content:center; align-items:center; z-index:2000;">
    <div style="background:var(--third-color); padding:20px; border-radius:8px; width:300px;">
      <h3>Import Instance</h3>
      <p>Select source:</p>
      <button id="importMrpackBtn">From Modrinth (.mrpack)</button>
      <button id="importFromZipBtn">From CurseForge (.zip)</button>
      <div style="margin-top:10px;">
        <button id="importCancelBtn">Cancel</button>
      </div>
    </div>
  </div>

  <div id="instance-detail" style="display:none;">
  <div id="instance-toolbar-container"></div>
  <div id="instance-tab-content" class="tab-content"></div>
  <pre id="logs" style="height:200px; overflow:auto; border:1px solid var(--secondary-color); border-radius: var(--border-radius); padding:5px;"></pre>
</div>

  <script>
    const { ipcRenderer } = require('electron');
    let profiles = [];

    const profilesList = document.getElementById("profiles-list");
    const instanceDetail = document.getElementById("instance-detail");
    const nameEl = document.getElementById("instance-name");
    const infoEl = document.getElementById("instance-info");
    const logsEl = document.getElementById("logs");
    const searchInput = document.getElementById("searchInput");
    const filterLoader = document.getElementById("filterLoader");
    const filterVersion = document.getElementById("filterVersion");
    const addInstanceModal = document.getElementById("addInstanceModal");
    const modalCreateBtn = document.getElementById("modalCreateBtn");
    const modalCancelBtn = document.getElementById("modalCancelBtn");
    const instanceName = document.getElementById("instanceName");
    const instanceVersion = document.getElementById("instanceVersion");
    const instanceLoader = document.getElementById("instanceLoader");
    const instanceIcon = document.getElementById("instanceIcon");
    const importMrpackBtn = document.getElementById("importMrpackBtn");
    const sortSelect = document.getElementById("sortSelect");
    const editOrderBtn = document.getElementById("editOrderBtn");
    const searchsort = document.getElementById("search-sort");
    let editingOrder = false;

    const urlParams = new URLSearchParams(window.location.search);
    const instanceId = urlParams.get("i");

    // Fetch profiles
    ipcRenderer.send("get-profiles");
    ipcRenderer.once("profiles-list", (e, newProfiles) => { profiles = newProfiles; renderListOrDetail(); });
    ipcRenderer.on("profiles-updated", (e, newProfiles) => { profiles = newProfiles; renderListOrDetail(); });

    // small debounce helper
    function debounce(fn, wait = 150) {
      let t;
      return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), wait); };
    }

    // Attach listeners (only once)
    function attachFilterListeners() {
      if (searchInput) searchInput.addEventListener('input', debounce(renderListOrDetail, 120));
      if (filterLoader) filterLoader.addEventListener('change', renderListOrDetail);
      if (filterVersion) filterVersion.addEventListener('input', renderListOrDetail);
      if (sortSelect) sortSelect.addEventListener('change', async () => {
        // send sort preference to backend if you support it
        try { await ipcRenderer.invoke('sort-instances', sortSelect.value); } catch (e) { }
        renderListOrDetail();
      });
    }
    // call once on load
    attachFilterListeners();

    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    sortSelect.addEventListener("change", async () => {
      const sortValue = sortSelect.value;
      if (sortValue === "custom") {
        editOrderBtn.style.display = "inline-block";
      } else {
        editOrderBtn.style.display = "none";
        editingOrder = false;
      }

      if (sortValue !== "custom") {
        try {
          const sortedProfiles = await ipcRenderer.invoke("sort-instances", { mode: sortValue });
          if (sortedProfiles && Array.isArray(sortedProfiles)) {
            profiles = sortedProfiles;
            renderListOrDetail();
          }
        } catch (err) {
          console.error("Failed to sort instances:", err);
          console.log("Sorting failed: " + err.message);
        }
      }
    });

    [searchInput, filterLoader, filterVersion].forEach(el => {
      el.addEventListener("input", renderListOrDetail);
    });

    // Toggle editing order
    editOrderBtn.addEventListener("click", () => {
      editingOrder = !editingOrder;
      editOrderBtn.textContent = editingOrder ? "Save Order" : "Edit Order";

      if (editingOrder) {
        enableDragAndDrop();
      } else {
        saveCustomOrder();
      }
    });

    // Enable drag-and-drop reordering
    function enableDragAndDrop() {
      const items = profilesList.querySelectorAll("li.profile-item");
      items.forEach(li => {
        li.setAttribute("draggable", true);

        li.addEventListener("dragstart", e => {
          e.dataTransfer.setData("text/plain", li.dataset.id);
          li.classList.add("dragging");
        });

        li.addEventListener("dragend", () => li.classList.remove("dragging"));

        li.addEventListener("dragover", e => {
          e.preventDefault();
          const dragging = document.querySelector(".dragging");
          if (!dragging) return;
          const bounding = li.getBoundingClientRect();
          const offset = e.clientY - bounding.top;
          if (offset > bounding.height / 2) {
            li.parentNode.insertBefore(dragging, li.nextSibling);
          } else {
            li.parentNode.insertBefore(dragging, li);
          }
        });
      });
    }

    // Collect new order and send to backend
    async function saveCustomOrder() {
      const ids = Array.from(profilesList.querySelectorAll("li.profile-item"))
        .map(li => li.dataset.id)
        .filter(Boolean); // ignore the "Add instance" button

      try {
        const sortedProfiles = await ipcRenderer.invoke("sort-instances", { mode: "custom", order: ids });
        if (sortedProfiles && Array.isArray(sortedProfiles)) {
          profiles = sortedProfiles;
          renderListOrDetail();
        }
      } catch (err) {
        console.error("Failed to save custom order:", err);
        console.log("Saving custom order failed: " + err.message);
      }
    }

    // On load → ask backend for saved sort mode
    (async () => {
      const mode = await ipcRenderer.invoke("get-sort-mode");
      if (mode) sortSelect.value = mode;
    })();

    function applyFilters(list) {
      const query = searchInput.value.toLowerCase();
      const loaderFilter = filterLoader.value;
      const versionFilter = filterVersion.value.trim();

      return list.filter(p => {
        if (query && !p.name.toLowerCase().includes(query)) return false;
        if (loaderFilter && p.loader !== loaderFilter) return false;
        if (versionFilter && !p.version.includes(versionFilter)) return false;
        return true;
      });
    }


    async function renderListOrDetail() {
      const urlParams = new URLSearchParams(window.location.search);
      const instanceId = urlParams.get('i');

      // read filter/search values now
      const q = (searchInput?.value || '').trim().toLowerCase();
      const loaderFilterVal = (filterLoader?.value || '').trim();
      const versionFilterVal = (filterVersion?.value || '').trim().toLowerCase();
      const sortMode = (sortSelect?.value || 'custom');

      // copy profiles so we can sort/filter safely
      let list = Array.isArray(profiles) ? profiles.slice() : [];

      // FILTER
      if (q) list = list.filter(p => (p.name || '').toLowerCase().includes(q) || String(p.id).includes(q));
      if (loaderFilterVal) list = list.filter(p => (p.loader || '').toLowerCase() === loaderFilterVal.toLowerCase());
      if (versionFilterVal) list = list.filter(p => (p.version || '').toLowerCase().includes(versionFilterVal));

      // SORT
      if (sortMode && sortMode !== 'custom') {
        const [key, dir] = sortMode.split('_');
        list.sort((a, b) => {
          if (key === 'name') return ((a.name || '').toLowerCase().localeCompare((b.name || '').toLowerCase())) * (dir === 'asc' ? 1 : -1);
          if (key === 'created' || key === 'lastUsed') return ((a[key] || 0) - (b[key] || 0)) * (dir === 'asc' ? 1 : -1);
          return 0;
        });
      }

      const selectedPlayerId = await ipcRenderer.invoke("get-selected-player");

if (instanceId && instanceId !== 'NEWINSTANCE') {
    searchsort.style.display = "none";
    const profile = list.find(p => String(p.id) === String(instanceId));
    if (!profile) return;

    profilesList.style.display = "none";
    instanceDetail.style.display = "block";
    instanceDetail.innerHTML = ""; // clear previous content

    // TOP ROW: ICON + INFO + BUTTONS
    const topRow = document.createElement("div");
    topRow.className = "instance-top-row";
    topRow.style.display = "flex";
    topRow.style.alignItems = "center";
    topRow.style.justifyContent = "space-between";
    topRow.style.marginBottom = "10px";

    // LEFT: ICON + INFO
    const left = document.createElement("div");
    left.style.display = "flex";
    left.style.alignItems = "center";
    topRow.appendChild(left);

    const icon = document.createElement("img");
    icon.src = profile.icon || "https://tggamesyt.dev/assets/redstone_launcher_defaulticon.png";
    icon.style.width = "64px";
    icon.style.height = "64px";
    icon.style.marginRight = "10px";
    left.appendChild(icon);

    const info = document.createElement("div");
    const lastPlayed = profile.lastUsed ? new Date(profile.lastUsed).toLocaleString() : "Never";
    const created = profile.created ? new Date(profile.created).toLocaleString() : "Unknown";
    info.innerHTML = `
        <div style="font-size:1.2em;font-weight:bold">${profile.name}</div>
        <div style="font-size:0.9em;color:var(--text-color)">
            <span class="material-icons" style="vertical-align:middle;font-size:16px">sports_esports</span>
            ${profile.loader} ${profile.version} | Last Played: ${lastPlayed} | Created: ${created}
        </div>
    `;
    left.appendChild(info);

    // RIGHT: BUTTONS
    const right = document.createElement("div");
    right.style.display = "flex";
    right.style.justifyContent = "center";
    right.style.alignItems = "center";
    right.style.gap = "5px";
    right.style.paddingRight = "20px"
    topRow.appendChild(right);

    // Play button
    const playBtn = document.createElement("button");
    playBtn.innerHTML = `<i class="material-icons">play_arrow</i> Play`;
    playBtn.title = "Launch Profile";
    playBtn.onclick = () => {
        if (!selectedPlayerId) return (playBtn.innerHTML = "Select a player first!");
        ipcRenderer.send("launch-profile", { profileId: profile.id, playerId: selectedPlayerId });
    };
    right.appendChild(playBtn);

    // Edit button
    const editBtn = document.createElement("button");
    editBtn.innerHTML = `<i class="material-icons">edit</i>`;
    editBtn.title = "Edit Profile";
    editBtn.onclick = () => {
        instanceName.value = profile.name;
        instanceVersion.value = profile.version;
        instanceLoader.value = profile.loader;
        instanceIcon.value = "";
        modalCreateBtn.dataset.editingId = profile.id;
        modalCreateBtn._originalProfile = profile;
        addInstanceModal.style.display = "flex";
    };
    right.appendChild(editBtn);

    // Three-dot menu
    const menuBtn = document.createElement("button");
    menuBtn.innerHTML = `<i class="material-icons">more_vert</i>`;
    menuBtn.title = "More Options";
    right.appendChild(menuBtn);

    instanceDetail.appendChild(topRow);

// CONTEXT MENU
const menu = document.createElement("div");
menu.className = "instance-context hidden";
menu.style.position = "absolute";
menu.style.background = "var(--toolbar-bg)";
menu.style.border = "1px solid var(--base-color)";
menu.style.padding = "5px";
menu.style.zIndex = 1000;
menu.innerHTML = `
    <div class="menu-item" data-action="open">Open Folder</div>
    <div class="menu-item export-item" data-action="export">Export ▸
        <div class="submenu hidden">
            <div class="menu-item" data-export="modrinth">Modrinth Pack</div>
        </div>
    </div>
    <div class="menu-item" data-action="delete">Delete</div>
`;
document.body.appendChild(menu);

let menuVisible = false;
let ignoreNextClick = false;

function positionMenu(menuBtn) {
    const rect = menuBtn.getBoundingClientRect();
    menu.style.display = "block";

    let left = rect.left;
    let top = rect.bottom;

    const menuRect = menu.getBoundingClientRect();
    if (left + menuRect.width > window.innerWidth) left = window.innerWidth - menuRect.width - 10;
    if (top + menuRect.height > window.innerHeight) top = rect.top - menuRect.height;

    menu.style.left = left + "px";
    menu.style.top = top + "px";
}

function toggleMenu() {
    menuVisible = !menuVisible;
    if (menuVisible) {
        menu.style.display = "block"; // show
        positionMenu(menuBtn);
        ignoreNextClick = true;
        setTimeout(() => ignoreNextClick = false, 0);
    } else {
        menu.style.display = "none"; // hide
    }
}

// Toggle menu with button
menuBtn.addEventListener("click", e => {
    e.stopPropagation();
    toggleMenu();
});

// Close menu clicking outside
window.addEventListener("click", () => {
    if (!ignoreNextClick && menuVisible) {
        menu.style.display = "none";
        menuVisible = false;
    }
});

// Menu follows window resize
window.addEventListener("resize", () => {
    if (menuVisible) positionMenu(menuBtn);
});

// Submenu hover with delay
menu.querySelectorAll(".export-item").forEach(item => {
    const submenu = item.querySelector(".submenu");
    let hoverTimer, leaveTimer;
    const HOVER_DELAY = 400;
    const LEAVE_GRACE = 100;

    const showSubmenu = () => {
        clearTimeout(leaveTimer);
        hoverTimer = setTimeout(() => {
            submenu.classList.remove("hidden");

            const parentRect = item.getBoundingClientRect();
            const subRect = submenu.getBoundingClientRect();

            if (parentRect.right + subRect.width > window.innerWidth) submenu.style.left = `-${subRect.width}px`;
            else submenu.style.left = `${item.offsetWidth}px`;

            if (parentRect.top + subRect.height > window.innerHeight) submenu.style.top = `${item.offsetHeight - subRect.height}px`;
            else submenu.style.top = "0px";
        }, HOVER_DELAY);
    };
    const hideSubmenu = () => {
        clearTimeout(hoverTimer);
        leaveTimer = setTimeout(() => submenu.classList.add("hidden"), LEAVE_GRACE);
    };

    item.addEventListener("pointerenter", showSubmenu);
    item.addEventListener("pointerleave", hideSubmenu);
    submenu.addEventListener("pointerenter", showSubmenu);
    submenu.addEventListener("pointerleave", hideSubmenu);
});

// Main menu item clicks
menu.querySelectorAll(".menu-item").forEach(item => {
    if (!item.classList.contains("export-item")) {
        item.addEventListener("click", e => {
            e.stopPropagation();
            if (item.dataset.action === "open") ipcRenderer.send("open-folder", { id: profile.id, isClient: true });
            if (item.dataset.action === "delete" && confirm(`Delete "${profile.name}"?`)) ipcRenderer.send("delete-profile", profile.id);

            menu.style.display = "none";
            menuVisible = false;
        });
    }
});

// Submenu clicks
menu.querySelectorAll(".submenu .menu-item").forEach(sub => {
    sub.addEventListener("click", async e => {
        e.stopPropagation();
        if (sub.dataset.export === "modrinth") await ipcRenderer.invoke("export-mrpack", profile.id);

        menu.style.display = "none";
        menuVisible = false;
    });
});

// Prevent menu click from closing itself
menu.addEventListener("click", e => e.stopPropagation());



    // TABS ROW
    const tabsRow = document.createElement("div");
    tabsRow.className = "instance-tabs-row";
    instanceDetail.appendChild(tabsRow);

    const tabs = ["Logs", "Resourcepacks", "Mods", "Shaderpacks", "Worlds", "Servers", "Screenshots"];
    const tabButtons = {};
    const tabContent = document.createElement("div");
    tabContent.classList.add("instanceView-scrolly");
    tabContent.id = "instance-tab-content";
    tabContent.style.marginTop = "10px";
    instanceDetail.appendChild(tabContent);

    // Helper to create card
    function createProfileCard(p, folderPath, button = false, buttontext = null, buttonlink = null) {
        const li = document.createElement("li");
        li.className = "profile-item";

        const img = document.createElement("img");
        img.src = p.icon || "https://tggamesyt.dev/assets/redstone_launcher_defaulticon.png";
        li.appendChild(img);

        const info = document.createElement("div");
        info.className = "profile-info";

        const name = document.createElement("div");
        name.className = "profile-name";
        name.textContent = p.name;
        info.appendChild(name);

        const details = document.createElement("div");
        details.className = "profile-details";
        details.textContent = p.details || "";
        info.appendChild(details);

        li.appendChild(info);

        li.onclick = (e) => {
            ipcRenderer.send("open-folder-path", { pather: folderPath });
        };
        return li;
    }
    // Helper to render tab file lists (keeps scope access to tabContent)
    function renderTabList(files) {
        tabContent.innerHTML = "";
        const ul = document.createElement("ul");
        ul.className = "profile-list";

        for (let p of files) {
            ul.appendChild(createProfileCard(p, p.path));
        }

        tabContent.appendChild(ul);
    }

    let currentTabSession = 0; // global counter
    const tabCache = {}; // cache per profileId+tab combination
    // tabs loop
    for (let tab of tabs) {
        // servers tab always visible
        let alwaysVisible = tab.toLowerCase() === "logs" || tab.toLowerCase() === "servers";
        let exists = await ipcRenderer.invoke("check-instance-tab", { profileId: profile.id, tab: tab.toLowerCase() });
        if (!exists && !alwaysVisible) continue;

        const btn = document.createElement("button");
        btn.textContent = tab;
        btn.className = "instance-tab-btn";
        btn.onclick = async () => {
            const thisSession = ++currentTabSession;
            const tabName = tab.toLowerCase();
            const cacheKey = `${profile.id}:${tabName}`;
            const ensureStillActive = () => thisSession === currentTabSession;

            tabContent.innerHTML = "Loading...";
            logsEl.style.display = "none";

            // Check cache and show immediately if present
            if (tabCache[cacheKey]) {
                renderTabList(tabCache[cacheKey].files);
            }

            if (tab.toLowerCase() === "logs") {
                logsEl.style.display = "block";
                tabContent.innerHTML = "";
                tabContent.appendChild(logsEl);

                ipcRenderer.removeAllListeners('launcher-log');
                ipcRenderer.on('launcher-log', (event, msg) => {
                    if (!ensureStillActive()) return;
                    logsEl.textContent += msg + "\n";
                    logsEl.scrollTop = logsEl.scrollHeight;
                });
                ipcRenderer.removeAllListeners('launch-error');
                ipcRenderer.on('launch-error', (event, msg) => {
                    if (!ensureStillActive()) return;
                    logsEl.textContent += "[ERROR] " + msg + "\n";
                    logsEl.scrollTop = logsEl.scrollHeight;
                });

            } else if (["resourcepacks", "mods", "shaderpacks", "worlds"].includes(tabName)) {
                const files = await ipcRenderer.invoke("get-instance-tab-files", {
                    profileId: profile.id,
                    tab: tabName
                });
                if (!ensureStillActive()) return;

                // Start resolving details (with SHA1 + Modrinth lookup)
                const fileInfos = [];
                for (let f of files) {
                    if (!ensureStillActive()) return;
                    const info = await ipcRenderer.invoke("get-instance-tab-file-info", {
                        profileId: profile.id,
                        tab: tabName,
                        filename: f
                    });
                    if (!ensureStillActive()) return;
                    fileInfos.push(info);
                }

                if (!ensureStillActive()) return;

                // Cache and render fresh data
                tabCache[cacheKey] = { files: fileInfos, lastUpdated: Date.now() };
                renderTabList(fileInfos);
            } else if (tab.toLowerCase() === "servers") {
                logsEl.style.display = "none";
                const servers = await ipcRenderer.invoke("get-instance-servers", { profileId: profile.id });
                if (!ensureStillActive()) return;
                tabContent.innerHTML = "";

                const ul = document.createElement("ul");
                ul.className = "profile-list";
                for (let s of servers) {
                    if (!ensureStillActive()) return;
                    let icon = "https://tggamesyt.dev/assets/redstone_launcher_defaulticon.png";
                    if (s.icon != null) icon = `data:image/png;base64,${s.icon}`;
                    const card = createProfileCard({ name: s.name, details: s.ip, icon }, s.folder);
                    ul.appendChild(card);
                }

                const addBtn = document.createElement("button");
                addBtn.textContent = "Add Server";
                addBtn.onclick = async () => {
                    // same add server modal logic…
                };
                tabContent.appendChild(addBtn);
                tabContent.appendChild(ul);

            } else if (tab.toLowerCase() === "screenshots") {
                logsEl.style.display = "none";
                const screenshots = await ipcRenderer.invoke("get-instance-screenshots", { profileId: profile.id });
                if (!ensureStillActive()) return;
                tabContent.innerHTML = "";

                const ul = document.createElement("ul");
                ul.className = "profile-list";
                for (let ss of screenshots) {
                    if (!ensureStillActive()) return;
                    const li = document.createElement("li");
                    li.className = "profile-item";
                    const img = document.createElement("img");
                    img.src = ss.path;
                    img.style.height = "50%";
                    img.style.width = "50%";
                    li.appendChild(img);
                    const name = document.createElement("div");
                    name.textContent = ss.name;
                    li.appendChild(name);
                    li.onclick = () => ipcRenderer.send("open-folder-path", { pather: ss.path });
                    ul.appendChild(li);
                }
                if (!ensureStillActive()) return;
                tabContent.appendChild(ul);
            }
        };
        tabsRow.appendChild(btn);
        tabButtons[tab.toLowerCase()] = btn;
    }

    // default select logs if available
    if (tabButtons.logs) tabButtons.logs.click();

    return;
}



      // LIST VIEW
      searchsort.style.display = "block";
      profilesList.style.display = "block";
      instanceDetail.style.display = "none";

      profilesList.innerHTML = "";

      list.forEach(p => {
        const li = document.createElement("li");
        li.className = "profile-item";

        const img = document.createElement("img");
        img.src = p.icon || "https://tggamesyt.dev/assets/redstone_launcher_defaulticon.png";
        li.appendChild(img);

        const info = document.createElement("div");
        info.className = "profile-info";

        const name = document.createElement("div");
        name.className = "profile-name";
        name.textContent = p.name;
        info.appendChild(name);

        const details = document.createElement("div");
        details.className = "profile-details";
        details.textContent = `v${p.version} • ${p.loader}`;
        info.appendChild(details);

        li.appendChild(info);

        const openFolderBtn = document.createElement("button");
        openFolderBtn.textContent = "Open Folder";
        openFolderBtn.onclick = (e) => {
          e.stopPropagation();
          ipcRenderer.send("open-folder", { id: p.id, isClient: true });
        };
        li.appendChild(openFolderBtn);

        const launchBtn = document.createElement("button");
        launchBtn.className = "play-button";
        launchBtn.innerHTML = `<i class="material-icons">play_arrow</i>`;
        launchBtn.onclick = (e) => {
          e.stopPropagation();
          if (!selectedPlayerId) return launchBtn.innerHTML = "Select a player first!";
          window.location.href = `instances.html?i=${p.id}`;
          ipcRenderer.send("launch-profile", { profileId: p.id, playerId: selectedPlayerId });
        };
        li.appendChild(launchBtn);
        li.onclick = () => {
          window.location.href = `instances.html?i=${p.id}`;
        };

        profilesList.appendChild(li);
      });

      // Add Instance button
      const liAdd = document.createElement("li");
      liAdd.className = "profile-item";
      const iAdd = document.createElement("i");
      iAdd.className = "material-icons";
      iAdd.textContent = "add";
      const spanAdd = document.createElement("span");
      spanAdd.textContent = "Add an instance";

      liAdd.appendChild(iAdd);
      liAdd.appendChild(spanAdd);
      liAdd.style.cursor = "pointer";
      liAdd.onclick = () => {
        instanceLoader.value = "vanilla";
        addInstanceModal.style.display = "flex";
      };
      profilesList.appendChild(liAdd);

      // ✅ Auto-open the modal if NEWINSTANCE
      if (instanceId === 'NEWINSTANCE') {
        liAdd.click();
      }
    }

    // Modal buttons
    modalCancelBtn.onclick = () => {
      addInstanceModal.style.display = "none";
      delete modalCreateBtn.dataset.editingId;
      delete modalCreateBtn._originalProfile;
    };
    importMrpackBtn.onclick = async () => {
      try {
        const result = await ipcRenderer.invoke("import-mrpack");
        if (result?.success) {
          importMrpackBtn.textContent = `Imported: ${result.profile.name}`;
          ipcRenderer.send("get-profiles");
          importModal.style.display = "none";
          addInstanceModal.style.display = "none";
        } else {
          importMrpackBtn.textContent = "Failed: " + (result?.error || "Unknown");
        }
      } catch (err) {
        importMrpackBtn.textContent = "Error importing .mrpack: " + err.message;
      }
    };

    importFromZipBtn.onclick = async () => {
      try {
        const result = await ipcRenderer.invoke("import-curseforge-zip");
        if (result?.success) {
          importFromZipBtn.textContent = `Imported: ${result.profile.name}`;
          ipcRenderer.send("get-profiles");
          importModal.style.display = "none";
          addInstanceModal.style.display = "none";
        } else {
          importFromZipBtn.textContent = "Failed: " + (result?.error || "Unknown");
        }
      } catch (err) {
        importFromZipBtn.textContent = "Error importing .zip: " + err.message;
      }
    };

    importCancelBtn.onclick = () => {
      importModal.style.display = "none";
    };

    modalCreateBtn.onclick = async () => {
      const editingId = modalCreateBtn.dataset.editingId;

      if (editingId) {
        const original = modalCreateBtn._originalProfile;
        const updatedProfile = { id: editingId };

        // Only include changed fields
        if (instanceName.value.trim() !== original.name) {
          updatedProfile.name = instanceName.value.trim();
        }
        if (instanceVersion.value.trim() !== original.version) {
          updatedProfile.version = instanceVersion.value.trim();
        }
        if (instanceLoader.value !== original.loader) {
          updatedProfile.loader = instanceLoader.value;
        }
        if (instanceIcon.files.length > 0) {
          updatedProfile.icon = await fileToBase64(instanceIcon.files[0]);
        }

        // If no changes, just close
        if (Object.keys(updatedProfile).length === 1) {
          addInstanceModal.style.display = "none";
          delete modalCreateBtn.dataset.editingId;
          delete modalCreateBtn._originalProfile;
          return;
        }

        ipcRenderer.send("edit-profile", updatedProfile);
        delete modalCreateBtn.dataset.editingId;
        delete modalCreateBtn._originalProfile;
      } else {
        // Create mode
        if (instanceName.value == null) {
          let string = `${instanceVersion.value}`;
          if (instanceLoader.value != "vanilla" && instanceLoader.value != null) {
            string = `${instanceLoader.value} ${instanceVersion.value}`
            string = string.replace(/\b\w/g, c => c.toUpperCase());
          }
          instanceName.value = `${instanceVersion.value}`;
        }
        const newProfile = {
          name: instanceName.value.trim(),
          version: instanceVersion.value,
          loader: instanceLoader.value,
          icon: null
        };
        if (!newProfile.name || !newProfile.version) {
          return modalCreateBtn.textContent = "Fill name and version";
        }
        if (instanceIcon.files.length > 0) {
          newProfile.icon = await fileToBase64(instanceIcon.files[0]);
        }
        ipcRenderer.send("create-profile", newProfile);
      }

      addInstanceModal.style.display = "none";
    };

    function updatePresence(details, state = "Idle") {
      ipcRenderer.send('update-discord-presence', { details, state });
    }
    updatePresence("Looking at the instances")
  </script>
<script>
async function fetchVersions() {
  const response = await fetch('https://piston-meta.mojang.com/mc/game/version_manifest_v2.json');
  const data = await response.json();
  return data.versions; // array of {id, type, url, ...}
}

function populateSelect(versions, showAll) {
  const select = document.getElementById('instanceVersion');
  select.innerHTML = ''; // clear existing options

  const filtered = showAll ? versions : versions.filter(v => v.type === 'release');

  filtered.forEach(v => {
    const opt = document.createElement('option');
    opt.value = v.id;
    opt.textContent = v.id;
    select.appendChild(opt);
  });

  // optionally select latest release by default
  if (!showAll) {
    const latest = filtered.find(v => v.type === 'release');
    if (latest) select.value = latest.id;
  }
}

async function initVersionSelect() {
  const versions = await fetchVersions();
  const checkbox = document.getElementById('showAllVersions');

  // initial populate (release only)
  populateSelect(versions, false);

  // update select when toggle changes
  checkbox.addEventListener('change', () => {
    populateSelect(versions, checkbox.checked);
  });
}

// run on page load
initVersionSelect();
</script>

  <script src="sidebar.js"></script>
</body>

</html>